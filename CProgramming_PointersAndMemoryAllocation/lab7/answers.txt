// Noah Alharbi
// Lab 7
// CSCI330


- Program 7a
After running the program, I noticed that the ‘returned’ values of the variables x and y 
were not identical. Variable y returned the value 4294967295 which represents the maximum unsigned integer when including the limit.h header. The macros in this header limits the use of a variety of variables like the limit of maximum unsigned integer value we saw above. On the other hand, variable x returned -1. Within the block of code in the file lab7a.c, we set x = y. So why are the 2 values returned differently? The reason is that we used a different specifier inside the printf statement, the %u and the %d.  The %u recognizes that the value passed is an unsigned integer, so it displays the actual maximum value with no restrains. By using %d, the printf expects a signed integer and it treats the maximum value limit.h sat to the unsigned int as -1. 

- Program 7b 
After running the program, I noticed that the values returned are somewhat expected. By that I mean, in the code block in the file lab7b.c, we declared a void function, f, which creates 2 pointers. A pointer to an int, I, and a pointer to a float,F. What is interesting about this function is that it takes a void pointer as a parameter. Choosing a pointer of void type is smart in this program because we need the function to be able to recognize and receive any type of pointers we through at it. To clarify, in the code block in lab7b.c, in the main function, we called function f twice. The first time, we passed f a pointer to an integer, and in the second time, we passed f a pointer to a float. The use of void pointers made this possible. So the function will handle both pointers and process them according to the function’s instructions. Inside the f function, in the first time around, we passed the function a reference to an integer, x, that was created in main. f receives the address of x and creates 2 pointers to point at that value. The first pointer, I, has an integer type and the second pointer, F, is a float type pointer. In the printf statement the specifiers are used properly. So the output looked like: 
“lab7b: I is 3, F is 4.2039e-45” 
we can see that pointer, I, printed the 3 that has the address that was passed to the function, but why did F print 4.2039e-45? The reason is that when we created a pointer to a float and made it point to an integer, the pointer was assigned a smaller size number so it assigned garbage numbers at the end. In the second call to f, the output was:
“lab7b: I is 1077936128, F is 3” 
We can see that F printed correctly. However F is a pointer to a float, so shouldn’t the result be 3.0? Agai the use of %g specifier, eliminates all not necessary 0s. So the value printed was 3 not 3.0.


- Program 7c
After running the program, I noticed that the output ‘sum’ kept updating by adding a 0.1 every time. So I investigated the program and I found a while loop that was set to update the value of sum with the value of the previously declared double ‘d’ added to the old sum. For example, sum += d; The condition to stop the loop was if sum increased enough to exceed 1.5. There was another condition we implemented as we initialized the loop. This condition was if sum = 1. This condition was bypassed because the compiler could not recognize 0.1 as power of 2 complement. For example, if we changed the value we increment by to 0.5 instead of 0.1, the condition will apply and the loop will stop. The reason is that 0.5 is recognizable to the compiler as a 2’s complement. In the printf statement in the code block in lab7c.c, we used an interesting specifier, %lg, This specifier is similar to the %lf specifier in the sense that they both expect a float type data type which is a double. The double by nature is a floating point number which is represented by a number and a decimal. Using the %lf specifier would return a value with a decimal and many zeros at the end. However, what is interesting in the %lg specifier we used in this program, is that the ‘g’ in the specifier ignores all 0s that are not necessary. So instead of returning 0.100000000 (incase of %lf), it returns 0.1.  


- Program 7d 
After running the program, I noticed that the returned values were different. After investigating lab7d.c, it was noticeable that both values were supposed to be identical, based on the code block in the file. However, the first value represented was 33554431 while the second was 33554432. The code sets variables equal to each other with no additions whatsoever. But we should consider that we are using the header limit.h and we initialized i to be the INT_MAX / 4; What is important to notice here is that we declared i as an int and INT_MAX return the maximum value possible for a signed int, which is 2147483647. Next step, we assign a float to contain the value stored in i. By doing so, the float automatically adds 1 to the end of the sequence. For example, when we declare a float and make it hold the value of MAX_INT, and convert it back to int we get -2147483648. On the other hand, when we store the value of MAX_INT in an integer from the beginning, we get 2147483647. This is a known bug that occurs when converting ints to floats and back to ints. The cause of this is casting a float to an int does not round to the nearest integer. It “truncates”, that is, it rounds towards zero. A well know solution to this problem is the 0.5 trick which suggests adding a 0.5 to the float upon conversion.

-Program 7e
After running the program, the output displayed was as expected except for the cases of x(h) and y(h). By this I mean, to print the values of x and y initially, we used the %d specifier which expects signed integers. In the code block in lab7e.c, we initialized x and y as signed integers with values -3, and 3 respectively. The printf statement returned the 2 values as expected since we used the correct specifier. In the next case, we used a different specifier, which is %x. The %x specifier return the hexadecimal representation of the value. When we tried to print y(h), the program returned 3 which is the hexadecimal representation of the number 3. On the other hand, when we tried to print the hexadecimal value of x, the returned value was fffffffd, The reason for that is the compiler recognizes the hexadecimal representation of negative numbers with a representation in letters beginning with an f. I tried passing few negative values to and I came to the following conclusions: 
When I passed -1, x(h) returned ffffffff 
So I investigated the fact that ffffffff means -1 in hexadecimal. So i tried passing -13 to, and x(h) returned fffffff3
We can notice that fffffff does appear and it is followed by 3 which we already determined that it was the hexadecimal representation of the number 3. So combining the fffffff with 3, does concatenate the -1 to the 3, resulting in -13. 


-Program 7f
After running the program, I noticed the 2 values returned, representing the same variable, were different. The reason for that is the specifiers used in the printf statement. The printf statement has 2 specifies, %c, and %d. In the code block in lab7f.c, we declare a character type variable, ch, and assign it the value ‘1’. In the printf statement we tried to print the value stored in ch, once using the %c specifier, and once using the %d specifier. When we used the %c specifier, the value stored in ch, 1, was displayed successfully. However, when we used %d specifier I noticed few things: 
The compiler recognized that the char that was passed is the number 1 and %d represents the char ‘0’ to ‘9’ with the values 48 - 57. So, the representation of char ‘1’ is 49, char ‘2’ is 50, and char ‘3’ is 51 ….. 
If you pass a char that is a letter to the %d, there are also letters representation. Those representation range from char a-z, and the numerical representation assigned to them are in the range  97- 122. So, the representation of char ‘a’ is 97, char ‘b’ is 98, and char ‘c’ as 99 …….

